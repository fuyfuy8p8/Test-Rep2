&#x1F534; ***Здравствуйте уважаемый, преподаватель. Данное домашнее задание, я выполнил в новом файле, так как тот в котором начинал, уже переделано столько работы, что уже он выглядит как ужасный черновик. А так еще и тренировка дополнительная, по набору текста, работы с Markdown.***


# **Мое руководство по работе с GIT**&#x1F4D8;
-------------------------------------


>**Git**— самая популярная в мире распределённая система контроля версий. Линус Торвальдс, разработчик ядра ОС Linux, создал этот инструмент ещё в 2005 году, а сегодня Git активно поддерживается как проект с открытым исходным кодом. Огромное количество открытых и коммерческих проектов используют Git для контроля версий.

В данном руководстве буду собранны мною основные рабочие команды по работе с Git и отработаны за время создания данного руководства. А так же, на базе данного процесса, будут выполняться некоторые задания от преподавателей. 

**1. Как задать имя пользователя и адрес электронной почты**

Имя пользователя нужно, чтобы привязывать коммиты к вашему имени. Это не то же самое, что имя пользователя учётной записи GitHub, с помощью которого выполняется вход в профиль на GitHub. Задать или изменить имя пользователя можно с помощью команды git config. Новое имя будет автоматически отображаться в последующих коммитах, отправленных на GitHub через командную строку. Если хотите скрыть своё реальное имя, можно использовать в качестве имени пользователя Git произвольный набор символов.

>git config --global user.name "Tara Routray"

Кроме того, командой git config можно изменять адрес электронной почты, привязанный к вашим коммитам Git. Новый адрес электронной почты будет автоматически отображаться во всех дальнейших коммитах, поданных на GitHub через командную строку.

>git config --global user.email "dev@tararoutray.com"


**2. Кэширование учётных данных**

Кэшировать учётные данные можно с помощью параметра config с флагом --global. Так вы избавитесь от необходимости вручную вводить имя пользователя и пароль при создании нового коммита.

>git config --global credential.helper cache


**3. Инициализация репозитория**

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

>git init

**4. Добавление отдельных файлов или всех файлов в область подготовленных файлов**

Добавить отдельный файл в область подготовленных файлов можно параметром add с указанием имени файла. Просто замените somefile.js на актуальное имя.

>git add somefile.js

Кроме того, можно добавить все файлы и папки в эту область, предоставив wildcard . вместо имени файла:

>git add .


**5. Проверка статуса репозитория**

Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.

>git status


**6. Внесение изменений однострочным сообщением или через редактор**

При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра commit с флагом -m. Само сообщение вводится непосредственно после флага, в кавычках.

>git commit -m "Your short summary about the commit"

Также можно открыть текстовый редактор в терминале для написания полного сообщения коммита. Оно может состоять из нескольких строк текста, в котором подробно характеризуются изменения, внесённые в репозиторий.

>git commit


**7. Просмотр истории коммитов с изменениями**

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.

>git log -p


**8. Просмотр заданного коммита**

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

>git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29

Также можно использовать сокращённый хеш.

>git show 1af17e


**9. Просмотр изменений до коммита**

Можно просматривать список изменений, внесённых в репозиторий, используя параметр diff. По умолчанию отображаются только изменения, не подготовленные для фиксации.

>git diff

Для просмотра подготовленных изменений необходимо добавить флаг --staged.

>git diff --staged

Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.

>git diff somefile.js


**10. Удаление отслеживаемых файлов из текущего рабочего дерева**

Удалять файлы из текущего рабочего дерева можно с помощью параметра rm. При этом файлы удаляются и из индекса.

>git rm dirname/somefile.js

Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.

>git rm dirname/*.html




**11. Переименование файлов**

Переименовать файл или папку можно параметром mv. Для него указывается источник source и назначение destination. Источник — реально существующий файл или папка, а назначение — существующая папка.

>git mv dir1/somefile.js dir2

При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать.

**12. Отмена подготовленных и неподготовленных изменений**

Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром checkout. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр git checkout изменит указатель HEAD, чтобы задать указанную ветку как текущую.

>git checkout somefile.js

Восстановить подготовленный файл рабочего дерева можно параметром reset. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.

>git reset HEAD somefile.js

Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.

>git reset HEAD


**13. Изменение последнего коммита**

Внести изменения в последний коммит можно параметром commit с флагом *--amend.* Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.

>git commit --amend -m "Updated message for the previous commit"

Также можно вносить изменения в файлы, отправленные ранее. Например, вы изменили несколько файлов в ряде папок и хотите их записать как единый снимок, но забыли добавить в коммит одну из папок. Чтобы исправить такую ошибку, достаточно подготовить для фиксации остальные файлы и папки и создать коммит с флагами *--amend и --no-edit.*

>git add dir1
>git commit

***Here you forgot to add dir2 to commit, you can execute the
following command to amend the other files and folders.***

>git add dir2

>git commit --amend --no-edit

Флаг *--no-edit* позволит внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.

>&#x1F538; **Внимание! Не изменяйте публичные коммиты.**
>-------------------------------------------------------
>
>С помощью *amend* прекрасно исправляются локальные коммиты, а исправления можно >передать в общий репозиторий. Однако изменять коммиты, уже доступные другим >пользователям, не следует. Помните, что изменённые коммиты являются совершенно >новыми, а предыдущий коммит уже не будет доступен в текущей ветке. Последствия >будут такими же, как при отмене изменений публичного снимка.


**14. Откат последнего коммита**

Откатить последний коммит можно с помощью параметра revert. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.

>git revert HEAD

&#x1F535; **Разница между revert и reset**
------------------------------------------

Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.

У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.

**15. Откат заданного коммита**

Откатить проект до заданного коммита можно с помощью параметра revert и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.

>git revert 1af17e


**16. Создание новой ветки и переход в неё**

Создать новую ветку можно с помощью параметра branch, указав имя ветки.

>git branch new_branch_name

Но Git не переключится на неё автоматически. Для автоматического перехода нужно добавить флаг -b и параметр checkout.

>git checkout -b new_branch_name


**17. Просмотр списка веток**

Можно просматривать полный список веток, используя параметр branch. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.

>git branch

Также можно вывести список удалённых веток с помощью флага -a.

>git branch -a


**18. Удаление ветки**

Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

>git branch -d existing_branch_name

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

>git branch -D existing_branch_name

Вышеуказанные команды удаляют только локальную копию ветки. В удалённом репозитории она может сохраниться. Если хотите стереть удалённую ветку, выполните следующую команду:

>git push origin --delete existing_branch_name


**19. Слияние двух веток**

Объединить две ветки можно параметром merge с указанием имени ветки. Команда объединит указанную ветку с основной.

>git merge existing_branch_name

Если надо выполнить коммит слияния, выполните команду git merge с флагом *--no-ff*.

>git merge --no-ff existing_branch_name

Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.

**20. Отображение журнала фиксации в виде графика для текущей или всех веток**

Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра log и флагов *--graph --oneline --decorate*. Опция *--graph* выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами *--oneline* и *--decorate*, этот флаг упрощает понимание того, к какой ветке относится каждый коммит.

>git log --graph --oneline --decorate

Для просмотра истории коммитов по всем веткам используется флаг --all.

>git log --all --graph --oneline --decorate


**21. Прекращение слияния при конфликте**

Прервать слияние в случае конфликта можно параметром merge с флагом *--abort*. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

>git merge --abort

Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния.

>git reset


**22. Добавление удалённого репозитория**

Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.

>git remote add awesomeapp https://github.com/someurl..


**23. Просмотр удалённых URL-адресов**

Просматривать удалённые URL-адреса можно параметром remote с флагом -v. Этот параметр отображает удалённые подключения к другим репозиториям.

>git remote -v

Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле .git/config репозитория.


**24. Получение дополнительных сведений об удалённом репозитории**

Получить подробные сведения об удалённом репозитории можно с помощью параметра remote show с указанием имени репозитория — например, origin.

>git remote show origin

Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.


**25. Отправка изменений в удалённый репозиторий**

Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.

>git push origin main

Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.


**26. Получение изменений из удалённого репозитория**

Для загрузки изменений из удалённого репозитория используется параметр pull. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.

>git pull

Также можно просмотреть подробные сведения о загруженных файлах с помощью флага *--verbose.*

>git pull --verbose


**27. Слияние удалённого репозитория с локальным**

Слияние удалённого репозитория с локальным выполняется параметром merge с указанием имени удалённого репозитория.

>git merge origin


**28. Отправка новой ветки в удалённый репозиторий**

Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.

>git push -u origin new_branch


**29. Удаление удалённой ветки**

Чтобы избавиться от удалённой ветки, используйте параметр push с флагом --delete, указав имя удалённого репозитория и имя ветки.

>git push --delete origin existing_branch


**30. Использование перебазирования**

Для доступа к этой функции используйте параметр rebase с указанием имени ветки. Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок.

>git rebase branch_name

Эта команда изменит основу ветки с одного коммита на другой, как если бы вы начали ветку с другого коммита. В Git это достигается за счёт создания новых коммитов и применения их к указанному базовому коммиту. Необходимо понимать, что, хотя ветка и выглядит такой же, она состоит из совершенно новых коммитов.

&#x1F536; Добрового времени суток, уважаемый Вадим.
начинаю выполнять домашнее задание от третьего семинара. Для данного дз, я вновь перенс инструкцию в новый файл. Так как в предыдущем написано и наработано очень много. И что бы лучше было видно ДЗ.

1. Дополнить инструкцию по работе с Git командами для работы с удаленным репозиторием.
2. Для тренировки запушить этот файл в свой акаунт на GitHub'е в новый репозиторий.
2. Форкнуть ссылку под записью семинара.
3. Отправить по ней измененый (доделанный файл - инструкцию по работе с Git)
4. Сделать скриншот терминала с выполнеными командами по отправке файла на удаленный репозиторий.
5. Сделать скриншот удаленного репозитория куда отправил свой файл
6. Отправить на проверку.

# Git - Работа с удалёнными репозиториями

Работа с удалёнными репозиториями
Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

&#x1F536; ***Удалённый репозиторий может находиться на вашем локальном компьютере.
Вполне возможно, что удалённый репозиторий будет находиться на том же компьютере, на котором работаете вы. Слово «удалённый» не означает, что репозиторий обязательно должен быть где-то в сети или Интернет, а значит только — где-то ещё. Работа с таким удалённым репозиторием подразумевает выполнение стандартных операций отправки и получения, как и с любым другим удалённым репозиторием.***

**Просмотр удалённых репозиториев**
-----------------------------------
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:

>git clone https://github.com/schacon/ticgit
>
>Cloning into 'ticgit'...
>
>remote: Reusing existing pack: 1857, done.
>
>remote: Total 1857 (delta 0), reused 0 (delta 0)
>
>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
>
>Resolving deltas: 100% (772/772), done.
>
>Checking connectivity... done.
>$ cd ticgit
>
>$ git remote
>
>origin

Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:

>$ git remote -v
>
>origin https://github.com/schacon/ticgit (fetch)
>
>origin https://github.com/schacon/ticgit (push)

Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:

>$ cd grit
>
>$ git remote -v
>
>bakkdoor  https://github.com/bakkdoor/grit (fetch)
>
>bakkdoor  https://github.com/bakkdoor/grit (push)
>
>cho45     https://github.com/cho45/grit (fetch)
>
>cho45     https://github.com/cho45/grit (push)
>
>defunkt   https://github.com/defunkt/grit (fetch)
>
>defunkt   https://github.com/defunkt/grit (push)
>
>koke      git://github.com/koke/grit.git (fetch)
>
>koke      git://github.com/koke/grit.git (push)
>
>origin    git@github.com:mojombo/grit.git (fetch)
>
>origin    git@github.com:mojombo/grit.git (push)

Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записи и в них можно отправлять свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.

Обратите внимание на разнообразие протоколов, используемых при указании адреса удалённого репозитория.

**Добавление удалённых репозиториев**
-------------------------------------

В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду **git remote add <shortname> <url>**:

>$ git remote
>
>origin
>
>$ git remote add pb https://github.com/paulboone/ticgit
>
>$ git remote -v
>
>origin https://github.com/schacon/ticgit (fetch)
>
>origin https://github.com/schacon/ticgit (push)
>
>pb https://github.com/paulboone/ticgit (fetch)
>
>pb https://github.com/paulboone/ticgit (push)
>

Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду **git fetch pb**:

>$ git fetch pb
>
>remote: Counting objects: 43, done.
>
>remote: Compressing objects: 100% (36/36), done.
>
>remote: Total 43 (delta 10), reused 31 (delta 5)
>
>Unpacking objects: 100% (43/43), done.
>
>
>From https://github.com/paulboone/ticgit
>
> * [new branch]      master     -> pb/master
>
> * [new branch]      ticgit     -> pb/ticgit

Ветка master из репозитория Пола сейчас доступна вам под именем pb/master. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола.

**Получение изменений из удалённого репозитория — Fetch и Pull**
----------------------------------------------------------------

Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

>$ git fetch [remote-name]

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, **git fetch origin** извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда **git fetch** забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки (см. следующий раздел и главу Ветвление в Git чтобы получить больше информации), то вы можете использовать команду **git pull** чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда **git clone** автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

&#x1F536;***Начиная с версии 2.27, команда git pull выдаёт предупреждение, если настройка pull.rebase не установлена. Git будет выводить это предупреждение каждый раз пока настройка не будет установлена.***

***Если хотите использовать поведение Git по умолчанию (простое смещение вперёд если возможно — иначе создание коммита слияния): git config --global pull.rebase "false"***

***Если хотите использовать перебазирование при получении изменений: git config --global pull.rebase "true"*** 

**Отправка изменений в удалённый репозиторий (Push)**
-----------------------------------------------------

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: **git push <remote-name> <branch-name>**. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

>$ git push origin master

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду **push**. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду **push**, а после него выполнить команду **push** попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.

**Просмотр удалённого репозитория**
------------------------------------

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду **git remote show <remote>**. Выполнив эту команду с некоторым именем, например, origin, вы получите следующий результат:

>$ git remote show origin
>
>* remote origin
>
>  Fetch URL: https://github.com/schacon/ticgit
>
>  Push  URL: https://github.com/schacon/ticgit
>
>  HEAD branch: master
>
>  Remote branches:
>
>    master                               tracked
>
>    dev-branch                           tracked
>
>  Local branch configured for 'git pull':
>
>    master merges with remote master
>
>  Local ref configured for 'git push':
>
>    master pushes to master (up to date)

Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните **git pull**, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

Это был пример для простой ситуации и вы наверняка встречались с чем-то подобным. Однако, если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от git remote show:

>$ git remote show origin
>
>* remote origin
>
>  URL: https://github.com/my-org/complex-project
>
>  Fetch URL: https://github.com/my-org/complex-project
>
>  Push  URL: https://github.com/my-org/complex-project
>
>  HEAD branch: master
>
>  Remote branches:
>
>    master                           tracked
>
>    dev-branch                       tracked
>
>    markdown-strip                   tracked
>
>    issue-43                         new (next fetch will store in remotes/origin)
>
>    issue-45                         new (next fetch will store in remotes/origin)
>
>    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
>
>  Local branches configured for 'git pull':
>
>    dev-branch merges with remote dev-branch
>
>    master     merges with remote master
>
>  Local refs configured for 'git push':
>
>    dev-branch                     pushes to dev-branch                     (up to date)
>
>    markdown-strip                 pushes to markdown-strip                 (up to date)
>
>    master                         pushes to master                         (up to date)

Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении **git push**. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере, и для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении **git pull**.

**Удаление и переименование удалённых репозиториев**
----------------------------------------------------

Для переименования удалённого репозитория можно выполнить **git remote rename**. Например, если вы хотите переименовать pb в paul, вы можете это сделать при помощи **git remote rename**:

>$ git remote rename pb paul
>
>$ git remote
>
>origin
>
>paul

Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как pb/master, теперь стало paul/master.

Если по какой-то причине вы хотите удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать **git remote rm**:

>$ git remote remove paul
>
>$ git remote
>
>origin

При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.

# Как в Git поменять URL-адрес удаленного репозитория?
------------------------------------------------------

В процессе работы имеет место быть ситуация, когда в локальном репозитории проекта требуется поменять URL-адрес удаленного (remote) репозитория. Например, когда вы перемещаете проект из GitLab на GitHub.

Первая консольная команда, которая нам станет помошником:

>git remote -v

В результате работы команды на экран терминала будет выведена информация обо всех имеющихся удаленных репозиториях: а именно синоним-алиас (чаще всего это будет алиас origin) и url до удаленного репозитория.

> origin  git@github.com:USERNAME/REPOSITORY.git (fetch)
> 
>origin  git@github.com:USERNAME/REPOSITORY.git (push)

Поменять адресс удаленного репозитория легко с помощью простой консольной команды:

> git remote set-url origin https://github.com/USERNAME/REPOSITORY.git

В команде выше требуется не забыть заменить URL на нужный Вам.

В результате выполнения команды **git remote set-url origin https://github.com/USERNAME/REPOSITORY.git** вы сможете применять git push и ваш код будет уже пушить на новый репозиторий.
